 """The Red October Project
      I have a working title for my alternative battleship game, Red October. Yesterday, we spent some serious time working on it and realized that we were going to need to change how I had previously built things. Originally, each space in a ship's hull had a dictionary with two key-value pairs, x and y. These correspond to the location of the hull. When we started developing the concept for IsHit(), we realized that the hull would need a third key-value pair called hp (for hit point). I then realized that if we were adding in a new key-value pair and keeping track of each individual hull piece's hit point then I would need to change how both move and turn worked. Currently, a hull is list with each item in the list being a dictionary hull space. The move method deletes the last item in the list, moves the remaining pieces once in that direction and then inserts a new bow at the front of the ship. Turn does nearly the same thing, except it deletes the entire hull and makes a new one in the proper direction. Because these methods both delete information rather than just changing it, a ship would regain hp by moving as it replaced damaged pieces. Obviously, this isn't how I want the game to work.
      
      I just had an idea that instead of using a list for the hull I could use a dictionary and name each piece for their position on the ship {bow, upper mid ship, mid ship, lower mid ship, stern}, then depending on the ship, it could decide which axis or hull location to rotate on. I'll need to think about this more, especially about assignment, before I can make it a winning strategy for this section of the code. We could then assign an immutable tuple that determines which piece is connected to which piece. although that could also be two additional key value pairs. So a hull piece would look like this {midship:{x:10, y:20, hp:1, in_front:upper_midship, in_back:lower_midship}. How would we find the center to turn on?
        if length of hull is odd then len(hull)/2 + 1 else len(hull)/2 = the number of nodes to move through while counter < NoN: in_front[in_back] => in_front counter = counter +1. Once center is found, determine clock or counter if clock bow moves 90 degrees distance from center so if 2 from center, remain 2 from center in 90 degree direction.